#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
make_rule_consequents_to_latex.py
Author: Paulo V. de C. Souza (NOVA IMS) & Pedro Catarro (helper script autogenerated)
Purpose:
  - Read RuleFit rules from a CSV (default: outputs_knowledge/rulefit_rules.csv)
  - Derive human-readable consequents (English) from coefficient sign & magnitude
  - Print the rules + consequents to terminal
  - Save a LaTeX table (booktabs) for direct inclusion in papers

Usage (examples):
  python make_rule_consequents_to_latex.py
  python make_rule_consequents_to_latex.py --rules-csv outputs_knowledge/rulefit_rules.csv --out-tex rules_table.tex
  python make_rule_consequents_to_latex.py --top 40 --min-support 0.02 --round 2
"""

import argparse
import math
import pandas as pd
from pathlib import Path

def detect_coef_column(df):
    # Look for common coefficient/importance column names
    for cand in ["coef", "coefficient", "importance"]:
        if cand in df.columns:
            return cand
        # Sometimes capitalized or different case
        for c in df.columns:
            if c.lower() == cand:
                return c
    # Fallback: none
    return None

def main():
    ap = argparse.ArgumentParser(description="Convert RuleFit rules to English consequents and a LaTeX table.")
    ap.add_argument("--rules-csv", default="outputs_knowledge/rulefit_rules.csv", help="Path to RuleFit rules CSV")
    ap.add_argument("--out-tex", default="rules_table.tex", help="Output LaTeX file")
    ap.add_argument("--top", type=int, default=30, help="How many rules to include (after filtering/sorting)")
    ap.add_argument("--min-support", type=float, default=0.0, help="Minimum rule support to keep (0..1)")
    ap.add_argument("--round", dest="round_digits", type=int, default=3, help="Rounding for coefficients in text/table")
    ap.add_argument("--sort-by", default=None, choices=[None, "abscoef", "coef", "support"], help="Sort criterion (default keeps CSV order)")
    args = ap.parse_args()

    path = Path(args.rules_csv)
    if not path.exists():
        raise SystemExit(f"Rules CSV not found: {path}")

    df = pd.read_csv(path)
    # Normalize expected columns
    cols = {c.lower(): c for c in df.columns}
    rule_col = None
    for cand in ["rule", "rules"]:
        if cand in cols:
            rule_col = cols[cand]
            break
    if rule_col is None:
        raise SystemExit("Did not find a 'rule' column in the CSV.")

    coef_col = detect_coef_column(df)
    if coef_col is None:
        print("[warn] Coefficient column not found; consequents will be 'unknown effect'.")

    # optional columns
    support_col = cols.get("support", None)
    len_col = cols.get("len", None)

    # Filter by support if requested
    if support_col is not None and args.min_support > 0:
        df = df[df[support_col] >= args.min_support].copy()

    # Build direction/intensity
    def mk_consequent(coef_val: float) -> str:
        if coef_val is None or (isinstance(coef_val, float) and (math.isnan(coef_val) or math.isinf(coef_val))):
            return "THEN effect on consumption is unclear"
        if coef_val > 0:
            return f"THEN consumption tends to increase by ~{round(coef_val, args.round_digits)} units"
        elif coef_val < 0:
            return f"THEN consumption tends to decrease by ~{round(abs(coef_val), args.round_digits)} units"
        else:
            return "THEN consumption effect is ~0"

    # Compose working table
    work = pd.DataFrame()
    work["Rule"] = df[rule_col].astype(str)

    if coef_col is not None:
        coefs = pd.to_numeric(df[coef_col], errors="coerce")
        work["Coefficient"] = coefs.round(args.round_digits)
        work["|Coefficient|"] = coefs.abs()
        work["Consequent (English)"] = coefs.apply(mk_consequent)
    else:
        work["Coefficient"] = pd.NA
        work["|Coefficient|"] = pd.NA
        work["Consequent (English)"] = "THEN effect on consumption is unclear"

    if support_col is not None:
        work["Support"] = pd.to_numeric(df[support_col], errors="coerce").round(3)
    if len_col is not None:
        work["Len"] = pd.to_numeric(df[len_col], errors="coerce")

    # Sorting
    if args.sort_by == "abscoef" and coef_col is not None:
        work = work.sort_values("|Coefficient|", ascending=False)
    elif args.sort_by == "coef" and coef_col is not None:
        work = work.sort_values("Coefficient", ascending=False)
    elif args.sort_by == "support" and support_col is not None:
        work = work.sort_values("Support", ascending=False)
    # else: keep CSV order

    # Keep top-N
    if args.top and args.top > 0:
        work = work.head(args.top)

    # Print to terminal
    print("\n=== Top Rules with Consequents (English) ===")
    for i, row in work.iterrows():
        rule_str = row["Rule"]
        cons_str = row["Consequent (English)"]
        coef_str = row["Coefficient"]
        sup_str = row.get("Support", None)
        msg = f"- IF {rule_str} => {cons_str}"
        if pd.notna(coef_str):
            msg += f"  [coef={coef_str}]"
        if sup_str is not None and pd.notna(sup_str):
            msg += f"  [support={sup_str:.3f}]"
        print(msg)
    print("===========================================\n")

    # Save LaTeX (booktabs)
    # Keep a compact set of columns for the paper
    cols_for_tex = ["Rule", "Consequent (English)"]
    if "Coefficient" in work.columns: cols_for_tex.append("Coefficient")
    if "Support" in work.columns: cols_for_tex.append("Support")
    if "Len" in work.columns: cols_for_tex.append("Len")

    tex_table = work[cols_for_tex].to_latex(
        index=False,
        escape=True,
        longtable=False,
        bold_rows=False,
        caption="Top RuleFit rules with English consequents (sign and magnitude derived from linear coefficients).",
        label="tab:rulefit_rules",
    )

    out_tex = Path(args.out_tex)
    out_tex.write_text("% Auto-generated; include with \\input{...}\n" + tex_table, encoding="utf-8")
    print(f"[ok] LaTeX table saved to: {out_tex.resolve()}")

if __name__ == "__main__":
    main()
